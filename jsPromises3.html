<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Promises</title>
</head>
<body>
    <script>
        // Here we are learning handeling multiple promises

        // let promise1 = new Promise((resolve,reject)=>{
        //     setTimeout(()=>{
        //         // resolve('[PROMISE 1] Resolved')
        //         resolve('A')
        //     },1000)
        // })
        // let promise2 = new Promise((resolve,reject)=>{
        //     setTimeout(()=>{
        //         // resolve('[PROMISE 2] Resolved')
        //         // resolve('B')
        //         reject('B') 
        //         /*  Here after 3sec we will get o/p as 'B' only and if there is another rejectmessage  in promises it will not get print because --> Rejected value will be the first rejected promise value */
        //         // reject('[PROMISE 2] Rejected')
        //     },3000)
        // })
        // let promise3 = new Promise((resolve,reject)=>{
        //     setTimeout(()=>{
        //         // resolve('[PROMISE 3] Resolved')
        //         // resolve('Z')
        //         reject('Z') //  Here after 5sec we will get o/p as 'Z' only no Array like structures because here promise is rejecting
        //         // reject('[PROMISE 3] Rejected')
        //     },5000)
        // })

        // promise1
        // .then((resolvedMessage)=>console.log(resolvedMessage))
        // .catch((err)=> console.log(err))
        
        // promise2
        // .then((resolvedMessage)=>console.log(resolvedMessage))
        // .catch((err)=> console.log(err))
        
        // promise3
        // .then((resolvedMessage)=>console.log(resolvedMessage))
        // .catch((err)=> console.log(err))

        // 
        /* Promise.all(): 
          -- Note : here we are not concerned about format,structure,or the odering i.e promise 1 run first and then promise 2
          -- We just need to concern that all the promises should get resolved 
        */
        /* 
        Pointers related to Promise.all()
        - will only resolve if 'ALL' promises gets resolved (can be related to &&(AND) operator)
        - Overall resolved value will be an array of resolved values from all promises
        - Rejected value will be the first rejected promise value
        - Overall promise resolve time = resolve time  of promise which takes largest time
        */

        // Promise.all([promise1,promise2,promise3])
        // .then((resolvedMessage)=>console.log(resolvedMessage))
        // .catch((err)=>console.log(err))
 

        // <!----------------------jfglh;dg------------->
        // Here is another method Where we are not concered with all the Promises where we are just concerned with atleast one promises get resolved  so we use Promise.any()

        let promise1 = new Promise((resolve,reject)=>{
            setTimeout(()=>{
                // resolve('[PROMISE 1] Resolved')
                reject('[PROMISE 1] Rejected')            
            },1000)
        })
        let promise2 = new Promise((resolve,reject)=>{
            setTimeout(()=>{
                // resolve('[PROMISE 2] Resolved')
                reject('[PROMISE 2] Rejected')
            },3000)
        })
        let promise3 = new Promise((resolve,reject)=>{
            setTimeout(()=>{
                // resolve('[PROMISE 3] Resolved')
               reject('[PROMISE 3] Rejected')
            },5000)
        })

        /* 
        -- Will resolve even if a 'SINGLE' promise gets resolved (can be related to ||(OR) operator)
        -- Overall resolved value = Resolved value of first resolved promise
        --Rejected promises will be skipped,If all promises are rejected 
        -- Promise.any() will be rejected (catch handler will work)
        -- Overall promise resolve time = resolve time of promise which takes the shortest time.
        */

     Promise.any([promise1,promise2,promise3])
        .then((resolvedMessage)=>console.log(resolvedMessage))
        .catch((err)=>console.log(err))
 
        // Note : We will get output as [PROMISE 1] Resolved because it will get resolved in 1sec so here .any() is a greedy method it will try to  execute as fast as possible. so that's why it will give the ans which is less in time .
    </script>
</body>
</html>